\chapter{Algèbre et calcul formel}
\subsection{Ensembles}
La notion d'objet immuable en Python est fondamentale,  une structure qui rappel les ensembles en mathématiques que soit fini ou infini est \textit{set}, importante, bien que
dans le cadre de SymPy elle s'appui entièrement sur Python avec certain modification, avec la collection d'objet.
\\

\textit{La fonction set accepte donc en argument un objet de type quelconque et s'efforce de le traduire dans un ensemble. Lorsqu'on ne passe aucun argument à set (option 2), ou qu'on lui passe une liste vide, set renvoie naturellement un ensemble vide; on aurait pu utiliser aussi bien, de la même manière, set(()), set({}), ou même set('') pour arriver au même résultat.}

\begin{exercise}
		Définir deux ensembles $X = \lbrace a, b, c, d\rbrace$ et  $Y = \lbrace s, b, d\rbrace$ , puis 			affichez les résultats suivants :
 		\begin{enumerate}
  			 \item les ensembles initiaux.
  			 \item le test d’appartenance de l’élément $c$ à $X$.
  			 \item le test d’appartenance de l’élément $a$ à $Y$.
  			 \item les ensembles $X - Y$ et $Y - X$.
  			 \item l’ensemble $X \cup Y$ (union).
  			 \item l'ensemble $X \cap Y$ (intersection).
	 \end{enumerate}
\end{exercise}

\begin{solution}
Il faut noter qu'il existe une solution qui se base sur le Python builtuints en utilisant la structure de donnée \textit{sets}. Mais comme en n'est dans la logique en utilise 
\begin{python}
from sympy import FiniteSet

X = FiniteSet('a', 'b', 'c', 'd')
Y = FiniteSet('s', 'b', 'd')

class MyClass(Yourclass):
    def __init__(self, my, yours):
        bla = '5 1 2 3 4'
        print bla
\end{python}
\begin{python}
class MyClass(Yourclass):
    def __init__(self, my, yours):
        bla = '5 1 2 3 4'
        print bla
\end{python}

\end{solution}
%%
\subsection{Logique}
\begin{exercise}
Dans la carte de Karnaugh ci-dessous, $X$ indique un terme sans intérêt. Quelle est la forme minimale de la fonction représentée par la carte de Karnaugh?
\end{exercise}
\subsection{Ensembles}
La notion d'objet immuable en Python est fondamentale,  une structure qui rappel les ensembles en mathématiques que soit fini ou infini est \textit{set}, importante, bien que
dans le cadre de SymPy elle s'appui entièrement sur Python avec certain modification, avec la collection d'objet.
\\

\textit{La fonction set accepte donc en argument un objet de type quelconque et s'efforce de le traduire dans un ensemble. Lorsqu'on ne passe aucun argument à set (option 2), ou qu'on lui passe une liste vide, set renvoie naturellement un ensemble vide; on aurait pu utiliser aussi bien, de la même manière, set(()), set({}), ou même set('') pour arriver au même résultat.}

	\begin{exercise}
		Définir deux ensembles $X = \lbrace a, b, c, d\rbrace$ et  $Y = \lbrace s, b, d\rbrace$ , puis 			affichez les résultats suivants :
 		\begin{enumerate}
  			 \item les ensembles initiaux.
  			 \item le test d’appartenance de l’élément $c$ à $X$.
  			 \item le test d’appartenance de l’élément $a$ à $Y$.
  			 \item les ensembles $X - Y$ et $Y - X$.
  			 \item l’ensemble $X \cup Y$ (union).
  			 \item l'ensemble $X \cap Y$ (intersection).
	 \end{enumerate}
	\end{exercise}

\begin{solution}
Il faut noter qu'il existe une solution qui se base sur le Python builtuints en utilisant la structure de donnée \textit{sets}. Mais comme en n'est dans la logique en utilise 
\begin{python}
from sympy import FiniteSet

X = FiniteSet('a', 'b', 'c', 'd')
Y = FiniteSet('s', 'b', 'd')

class MyClass(Yourclass):
    def __init__(self, my, yours):
        bla = '5 1 2 3 4'
        print bla
\end{python}
\begin{python}
class MyClass(Yourclass):
    def __init__(self, my, yours):
        bla = '5 1 2 3 4'
        print bla
\end{python}

\end{solution}
%\begin{exercise}
%Si $P$, $Q$, $R$ sont des sous-ensembles de l'ensemble universel $U$, alors $(P \cap Q\capR) \cup (P^{c} \cap Q \cap R)\cup(Q^{x}\cupR^{x})$ si
%\begin{enumerate}
%  \item  
%  \item 
%  \item
%\end{enumerate}
%\end{exercise}
%------------------------------------------------
\subsection{Polynômes}
\begin{exercise}
Considérons le polynôme $p(x) = a_{0} + a_{1} x + a_{2} x^{2} + a_{3} x^{3}$, où $a_{i} \neq 0$ $\forall i$. Le nombre minimum de multiplications nécessaires pour évaluer $p$ sur une entrée $x$ est:
\end{exercise}
%-----------------------------------------------
\subsection{Nombres parfaits et nombres chanceux}
\begin{exercise}
$\sqrt{12}$
\end{exercise}
%------------------------------------------------
%------------------------------------------------

\section{Examples}\index{Examples}

This is an example of examples.

\subsection{Equation and Text}\index{Examples!Equation and Text}

\begin{example}
Let $G=\{x\in\mathbb{R}^2:|x|<3\}$ and denoted by: $x^0=(1,1)$; consider the function:
\begin{equation}
f(x)=\left\{\begin{aligned} & \mathrm{e}^{|x|} & & \text{si $|x-x^0|\leq 1/2$}\\
& 0 & & \text{si $|x-x^0|> 1/2$}\end{aligned}\right.
\end{equation}
The function $f$ has bounded support, we can take $A=\{x\in\mathbb{R}^2:|x-x^0|\leq 1/2+\epsilon\}$ for all $\epsilon\in\intoo{0}{5/2-\sqrt{2}}$.
\end{example}
%------------------------------------------------------------------------------
%	CHAPTER 3
%----------------------------------------------------------------------------------------

\section{Programmation Orientée Objet}\index{Notations}
\begin{notation}
Given an open subset $G$ of $\mathbb{R}^n$, the set of functions $\varphi$ are:
\begin{enumerate}
\item Bounded support $G$;
\item Infinitely differentiable;
\end{enumerate}
a vector space is denoted by $\mathcal{D}(G)$. 
\end{notation}

 \subsection{POO}
\begin{exercise}
 Définir une classe Vecteur2D avec un constructeur fournissant les coordonnées par
défaut d’un vecteur du plan (par exemple : $x = 0$ et $y = 0$ ).
Dans le programme principal, instanciez un Vecteur2D sans paramètre, un Vecteur2D
avec ses deux paramètres, et affichez-les.
\end{exercise}
\begin{solution}
 en utilise le module sympy.geometry ce module fait appel à tout les outils et theories qui
 peuvents entre utiliser dans le cade de la géométrie dans le Plan.
 \begin{python}
 from sympy.geometry
  \end{python}
\end{solution}

\begin{exercise}
Enrichissez la classe Vecteur2D précédente en lui ajoutant une méthode d’affichage
et une méthode de surcharge d’addition de deux vecteurs du plan.
Dans le programme principal, instanciez deux Vecteur2D , affichez-les et affichez leur
somme.
\end{exercise}
\begin{solution}
\end{solution}

%------------------------------------------------
\subsection{Notions de COO et d’encapsulation}
%------------------------------------------------

%%
%\includeonly{geometry/euclid}
